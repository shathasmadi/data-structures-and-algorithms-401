/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import java.util.*;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());
//
//        BinarySearchTree <Integer> test = new BinarySearchTree<>();
//        test.setRoot(new Node(10));
//        test.getRoot().setLeft(new Node(8));
//        test.getRoot().getLeft().setLeft(new Node(6));
//        test.getRoot().setRight(new Node(12));
//        test.add(10);
//        System.out.println(test.inOrder(test.getRoot()));
//
//        BinarySearchTree <Integer> testTwo = new BinarySearchTree<>();
//        testTwo.add(10);
//        testTwo.add(15);
//        testTwo.add(30);
//        testTwo.add(12);
//        testTwo.add(8);
//        testTwo.add(9);
//        testTwo.add(5);
//
//        System.out.println(testTwo.contains(50));
//
//
//
//
//        System.out.println(testTwo.findMaxValue());
//
//
//        System.out.println(breadthFirstTree(testTwo));

        KaryTree<Integer> testt = new KaryTree<>(3);
        testt.add(50);
        testt.add(20);
        testt.add(15);
        System.out.println(fizzBuzzTree(testt).root.data);
        System.out.println(testt.root.data);



        BinaryTree<Integer> treeOne = new BinaryTree<>();
        treeOne.setRoot(new Node<>(150));
        treeOne.getRoot().setRight(new Node<>(250)) ;
        treeOne.getRoot().setLeft(new Node<>(100));
        treeOne.getRoot().getRight().setRight(new Node<>(350));
        treeOne.getRoot().getRight().getRight().setRight(new Node<>(500));
        treeOne.getRoot().getRight().getRight().setLeft(new Node<>(300));
        treeOne.getRoot().getRight().setLeft(new Node<>(200)) ;
        treeOne.getRoot().getLeft().setLeft(new Node<>(75))  ;
        treeOne.getRoot().getLeft().setRight(new Node<>(160));
        treeOne.getRoot().getLeft().getRight().setLeft(new Node<>(125)) ;
        treeOne.getRoot().getLeft().getRight().setRight(new Node<>(175));




        BinaryTree<Integer> treeTwo = new BinaryTree<>();
        treeTwo.setRoot(new Node<>(42));
        treeTwo.getRoot().setRight(new Node<>(600)) ;
        treeTwo.getRoot().setLeft(new Node<>(100));
        treeTwo.getRoot().getRight().setRight(new Node<>(350));
        treeTwo.getRoot().getRight().getRight().setRight(new Node<>(500));
        treeTwo.getRoot().getRight().getRight().setLeft(new Node<>(4));
        treeTwo.getRoot().getRight().setLeft(new Node<>(200)) ;
        treeTwo.getRoot().getLeft().setLeft(new Node<>(15))  ;
        treeTwo.getRoot().getLeft().setRight(new Node<>(160));
        treeTwo.getRoot().getLeft().getRight().setLeft(new Node<>(125)) ;
        treeTwo.getRoot().getLeft().getRight().setRight(new Node<>(175));


        System.out.println(treeIntersection(treeOne, treeTwo).toString());



    }

  public static ArrayList<Integer> breadthFirstTree(BinaryTree<Integer> tree){
       ArrayList<Integer>list=new ArrayList<Integer>();
         Queue<Node> queue= new LinkedList<>();
        if (tree.getRoot()!=null){
            queue.add(tree.getRoot());
            while(!queue.isEmpty()){
              Node node = queue.remove();
              list.add((int)node.getData());
              if (node.getLeft()!= null){
                  queue.add(node.getLeft());
              }
                if (node.getRight()!= null){
                    queue.add(node.getRight());
                }
            }
        }
        return list ;
   }

    public static KaryTree<String> fizzBuzzTree(KaryTree<Integer> kTree){
        KaryTree<String> outSideTree = new KaryTree<>(kTree.K);
        Queue<KNode> queue = new LinkedList<>();
        if(!kTree.isEmpty()){
            queue.add(kTree.root);
            while(!queue.isEmpty()){
                KNode<Integer> currNode = queue.poll();
                String currValue;
                if(currNode.data % 3 == 0 && currNode.data % 5 ==0 )
                    currValue = "FizzBuzz";
                else if((int)currNode.data % 3 == 0)
                    currValue="Fizz";
                else if((int)currNode.data % 5 == 0)
                    currValue="Buzz";
                else
                    currValue=currNode.data.toString();
                outSideTree.add(currValue);

                if(! currNode.children.isEmpty())
                    queue.addAll(currNode.children);
            }
        }
        return outSideTree;
    }




    public static HashSet treeIntersection(BinaryTree treeOne, BinaryTree treeTwo){

        List listOne=treeOne.inOrder(treeOne.getRoot());
        List listTwo=treeTwo.inOrder(treeTwo.getRoot());
        HashSet finalResult=new HashSet();
        for (Object value:listOne){
            if (listTwo.contains(value)){
                finalResult.add(value);
            }
        }
        return finalResult;
    }


}
